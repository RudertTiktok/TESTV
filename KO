local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Stats = game:GetService("Stats")

if not game:IsLoaded() then
    game.Loaded:Wait()
end

local LocalPlayer = Players.LocalPlayer
local RunTime = Workspace.Runtime
local Alive = Workspace.Alive
local Dead = Workspace.Dead
local Settings = {
    AutoParryEnabled = true, -- Diaktifkan secara default untuk pengujian
    AutoSpamEnabled = false,
    CursorTargeting = false
}
local Grab_Parry = nil
local Parry_Key = nil
local Remotes = {}
local ConnectionsManager = {}
local Camera = Workspace.CurrentCamera
local Closest_Entity = nil
local Parries = 0
local Last_Input = nil
local TargetSelectionMethod = "ClosestToPlayer"
local is_respawned = false

-- Struktur data
local AutoParry = {
    target = { current = nil, from = nil, aim = nil },
    ball = {
        properties = {
            aero_dynamic_time = tick(),
            last_position = Vector3.zero,
            rotation = Vector3.zero,
            distance = 0,
            speed = 0,
            velocity = Vector3.zero,
            direction = Vector3.zero,
            dot = 0,
            maximum_speed = 0,
            last_hit = 0,
            parries = 0,
            spam_range = 0,
            parry_range = 0,
            auto_spam = false,
            cooldown = false,
            last_warping = tick(),
            is_curved = false,
            hell_hook_completed = true,
            last_curve_position = Vector3.zero,
            lerp_radians = 0,
            radians = 0,
            old_speed = 0,
            position = Vector3.zero,
            respawn_time = 0
        },
        ball_entity = nil,
        client_ball_entity = nil
    },
    entity_properties = { distance = 0, velocity = Vector3.zero, direction = Vector3.zero, server_position = Vector3.zero, is_moving = false, speed = 0, dot = 0 },
    Spam_Sensitivity = 50,
    Ping_Based_Spam = true,
    Parry_Type = "Straight" -- Default ke Straight untuk pengujian
}

local Player = {
    Entity = {
        properties = {
            ping = 0,
            sword = "",
            server_position = Vector3.zero,
            velocity = Vector3.zero,
            speed = 0,
            is_moving = false,
            grab_animation = nil
        }
    }
}

local Animation = {
    storage = {},
    track = nil,
    current = nil
}

-- Scanning remote
task.spawn(function()
    print("Scanning for remotes...")
    for _, Value in getgc() do
        if type(Value) == 'function' and islclosure(Value) then
            local Protos = debug.getprotos(Value)
            local Upvalues = debug.getupvalues(Value)
            local Constants = debug.getconstants(Value)
            if #Protos == 4 and #Upvalues == 24 and #Constants >= 102 then
                local c62 = Constants[62]
                local c64 = Constants[64]
                local c65 = Constants[65]
                Remotes[debug.getupvalue(Value, 16)] = c62
                Parry_Key = debug.getupvalue(Value, 17)
                Remotes[debug.getupvalue(Value, 18)] = c64
                Remotes[debug.getupvalue(Value, 19)] = c65
                print("Remotes found:", Remotes, "Parry_Key:", Parry_Key)
                break
            end
        end
    end
    if not Parry_Key then
        warn("Failed to find Parry_Key!")
    end
end)

local Key = Parry_Key

function AutoParry.Parry_Animation()
    print("Attempting to play parry animation...")
    local Current_Sword = LocalPlayer.Character and LocalPlayer.Character:GetAttribute("CurrentlyEquippedSword")
    if not Current_Sword then
        warn("No sword equipped!")
        return
    end
    local Sword_Data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(Current_Sword)
    if not Sword_Data or not Sword_Data['AnimationType'] then
        warn("Invalid sword data or animation type!")
        return
    end
    local Parry_Animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild("GrabParry")
    for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
        if object.Name == Sword_Data['AnimationType'] then
            local sword_animation_type = (object:FindFirstChild("GrabParry") and "GrabParry") or "Grab"
            Parry_Animation = object[sword_animation_type]
        end
    end
    if LocalPlayer.Character and LocalPlayer.Character.Humanoid and Parry_Animation then
        Grab_Parry = LocalPlayer.Character.Humanoid.Animator:LoadAnimation(Parry_Animation)
        Grab_Parry:Play()
        print("Parry animation played!")
    else
        warn("Failed to load parry animation!")
    end
end

function AutoParry.Play_Animation(animationName)
    print("Playing animation:", animationName)
    local Animations = Animation.storage[animationName]
    if not Animations then
        warn("Animation not found:", animationName)
        return false
    end
    local Animator = LocalPlayer.Character and LocalPlayer.Character.Humanoid and LocalPlayer.Character.Humanoid.Animator
    if not Animator then
        warn("No animator found!")
        return false
    end
    if Animation.track and Animation.track:IsA("AnimationTrack") then
        Animation.track:Stop()
    end
    Animation.track = Animator:LoadAnimation(Animations)
    if Animation.track and Animation.track:IsA("AnimationTrack") then
        Animation.track:Play()
        print("Animation track played:", animationName)
    end
    Animation.current = animationName
end

function AutoParry.Get_Balls()
    local Balls = {}
    for _, instance in pairs(Workspace.Balls:GetChildren()) do
        if instance:GetAttribute("realBall") then
            instance.CanCollide = false
            table.insert(Balls, instance)
            print("Found ball:", instance.Name)
        end
    end
    return Balls
end

function AutoParry.Get_Ball()
    for _, instance in pairs(Workspace.Balls:GetChildren()) do
        if instance:GetAttribute("realBall") then
            instance.CanCollide = false
            print("Selected ball:", instance.Name)
            return instance
        end
    end
    print("No realBall found!")
    return nil
end

function AutoParry.reset()
    print("Resetting AutoParry state...")
    local ball_properties = AutoParry.ball.properties
    ball_properties.is_curved = false
    ball_properties.auto_spam = false
    ball_properties.cooldown = false
    ball_properties.maximum_speed = 0
    ball_properties.parries = 0
    ball_properties.last_hit = 0
    AutoParry.target.current = nil
    AutoParry.target.from = nil
    AutoParry.target.aim = nil
end

function AutoParry.Parry_Data()
    print("Generating Parry_Data...")
    if not Camera then
        warn("No camera available!")
        return {0, CFrame.new(), {}, {0, 0}}
    end

    local ViewportSize = Camera.ViewportSize
    local MouseLocation = (Last_Input == Enum.UserInputType.MouseButton1 or Last_Input == Enum.UserInputType.MouseButton2 or Last_Input == Enum.UserInputType.Keyboard)
        and UserInputService:GetMouseLocation()
        or Vector2.new(ViewportSize.X / 2, ViewportSize.Y / 2)

    local Used = {MouseLocation.X, MouseLocation.Y}

    if TargetSelectionMethod == "ClosestToPlayer" then
        Closest_Entity = get_closest_entity()
        if Closest_Entity and Closest_Entity.PrimaryPart then
            Used = Camera:WorldToScreenPoint(Closest_Entity.PrimaryPart.Position)
            print("Closest entity selected:", Closest_Entity.Name)
        else
            print("No closest entity with PrimaryPart!")
        end
    end

    local Alive = Workspace.Alive:GetChildren()
    local Events = table.create(#Alive)
    for _, v in ipairs(Alive) do
        if v.PrimaryPart then
            Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
        end
    end

    local pos = Camera.CFrame.Position
    local look = Camera.CFrame.LookVector
    local up = Camera.CFrame.UpVector
    local right = Camera.CFrame.RightVector

    local directions = {
        Backwards = pos - look * 1000,
        Random = Vector3.new(math.random(-3000, 3000), math.random(-3000, 3000), math.random(-3000, 3000)),
        Straight = pos + look * 1000,
        Up = pos + up * 1000,
        Right = pos + right * 1000,
        Left = pos - right * 1000
    }

    local lookTarget = directions[AutoParry.Parry_Type] or (pos + look * 1000)
    local DirectionCF = CFrame.new(pos, lookTarget)

    print("Parry_Data generated:", DirectionCF)
    return {0, DirectionCF, Events, Used}
end

local foundFake = false
for _, Args in pairs(Remotes) do
    if Args == "PARRY_HASH_FAKE_1" or Args == "_G" then
        foundFake = true
        break
    end
end

function AutoParry.Parry()
    print("Parry triggered at:", tick(), "Cooldown:", AutoParry.ball.properties.cooldown)
    local Parry_Data = AutoParry.Parry_Data()
    for Remote, Args in pairs(Remotes) do
        local Hash = foundFake and nil or Args
        print("Firing remote:", Remote, "Hash:", Hash)
        Remote:FireServer(Hash, Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
    end
    if Parries > 7 then
        warn("Parry limit reached!")
        return false
    end
    Parries += 1
    AutoParry.ball.properties.cooldown = true
    AutoParry.Parry_Animation()
    task.delay(0.3, function()
        if Parries > 0 then
            Parries -= 1
            print("Parry count decreased:", Parries)
        end
    end)
end

function AutoParry.Is_Curved()
    local Ball = AutoParry.Get_Ball()
    if not Ball then
        print("Is_Curved: No ball found!")
        return false
    end
    local target = AutoParry.target.current
    if not target then
        print("Is_Curved: No target set!")
        return false
    end

    local ball_properties = AutoParry.ball.properties
    local current_target = target.Name
    print("Is_Curved: Checking for target:", current_target, "Distance:", ball_properties.distance)

    if target:FindFirstChild('MaxShield') and current_target ~= LocalPlayer.Name and ball_properties.distance < 50 then
        print("Is_Curved: MaxShield detected, not curved")
        return false
    end

    if AutoParry.ball.ball_entity then
        if AutoParry.ball.ball_entity:FindFirstChild('TimeHole1') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
            ball_properties.auto_spam = false
            print("Is_Curved: TimeHole1 detected, not curved")
            return false
        end

        if AutoParry.ball.ball_entity:FindFirstChild('WEMAZOOKIEGO') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
            print("Is_Curved: WEMAZOOKIEGO detected, not curved")
            return false
        end

        if AutoParry.ball.ball_entity:FindFirstChild('At2') and ball_properties.speed <= 0 then
            print("Is_Curved: At2 with zero speed, curved")
            return true
        end

        if AutoParry.ball.ball_entity:FindFirstChild('AeroDynamicSlashVFX') then
            Debris:AddItem(AutoParry.ball.ball_entity.AeroDynamicSlashVFX, 0)
            ball_properties.auto_spam = false
            ball_properties.aero_dynamic_time = tick()
            print("Is_Curved: AeroDynamicSlashVFX detected")
        end
    end

    if Workspace:FindFirstChild('Tornado') then
        if ball_properties.distance > 5 and (tick() - ball_properties.aero_dynamic_time) < (Workspace.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159 then
            print("Is_Curved: Tornado detected, curved")
            return true
        end
    end

    if not ball_properties.hell_hook_completed and target.Name == LocalPlayer.Name and ball_properties.distance > 5 then
        print("Is_Curved: Hell hook incomplete, curved")
        return true
    end
    
    local ball_direction = ball_properties.velocity.Magnitude > 0 and ball_properties.velocity.Unit or Vector3.zero
    local ball_speed = ball_properties.speed
    
    local speed_threshold = math.min(ball_speed / 100, 40)
    local angle_threshold = 40 * math.max(ball_properties.dot, 0)

    local player_ping = LocalPlayer:GetNetworkPing() * 1000

    local accurate_direction = ball_direction
    local direction_difference = ball_properties.velocity.Magnitude > 0 and (accurate_direction - ball_properties.velocity).Unit or Vector3.zero
    local accurate_dot = ball_properties.direction:Dot(direction_difference)
    local dot_difference = ball_properties.dot - accurate_dot
    local dot_threshold =  blogg0.5 - player_ping / 1000

    local reach_time = ball_properties.maximum_speed > 0 and ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000) or 0
    local enough_speed = ball_properties.maximum_speed > 100

    local ball_distance_threshold = 15 - math.min(ball_properties.distance / 1000, 15) + angle_threshold + speed_threshold
    
    if enough_speed and reach_time > player_ping / 10 then
        ball_distance_threshold = math.max(ball_distance_threshold - 10, 15)
    end
    
    if ball_properties.distance < ball_distance_threshold then
        print("Is_Curved: Distance below threshold, not curved")
        return false
    end

    if dot_difference < dot_threshold or ball_properties.dot < dot_threshold then
        print("Is_Curved: Dot difference or dot below threshold, curved")
        return true
    end

    if ball_properties.lerp_radians < 0.018 then
        ball_properties.last_curve_position = ball_properties.position
        ball_properties.last_warping = tick()
        print("Is_Curved: Low lerp_radians, updating last curve position")
    end

    if (tick() - ball_properties.last_warping) < (reach_time / 1.5) then
        print("Is_Curved: Recent warping, curved")
        return true
    end

    print("Is_Curved: Not curved")
    return false
end

local old_from_target = nil

function AutoParry:is_spam()
    local target = AutoParry.target.current
    print("Checking is_spam, Target:", target and target.Name or "nil")

    if not target then
        return false
    end

    if AutoParry.target.from ~= LocalPlayer.Character then
        old_from_target = AutoParry.target.from
    end

    if self.parries < 3 and AutoParry.target.from == old_from_target then
        print("is_spam: Too few parries or same from target")
        return false
    end

    local player_ping = Player.Entity.properties.ping
    local distance_threshold = 18 + (player_ping / 80)

    local ball_properties = AutoParry.ball.properties
    local reach_time = ball_properties.maximum_speed > 0 and ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000) or 0

    if (tick() - self.last_hit) > 0.8 and self.entity_distance > distance_threshold and self.parries < 3 then
        self.parries = 1
        print("is_spam: Recent hit and distance too far")
        return false
    end

    if ball_properties.lerp_radians > 0.028 then
        if self.parries > 3 then
            self.parries = 1
        end
        print("is_spam: High lerp_radians")
        return false
    end

    if (tick() - ball_properties.last_warping) < (reach_time / 1.3) and self.entity_distance > distance_threshold and self.parries < 4 then
        if self.parries > 3 then
            self.parries = 1
        end
        print("is_spam: Recent warping and distance too far")
        return false
    end

    if math.abs(self.speed - self.old_speed) < 5.2 and self.entity_distance > distance_threshold and self.speed < 60 and self.parries < 3 then
        if self.parries > 3 then
            self.parries = 0
        end
        print("is_spam: Stable speed and distance too far")
        return false
    end
    
    if self.speed < 10 then
        self.parries = 1
        print("is_spam: Speed too low")
        return false
    end

    if self.maximum_speed < self.speed and self.entity_distance > distance_threshold then
        self.parries = 1
        print("is_spam: Maximum speed exceeded")
        return false
    end

    if self.entity_distance > self.range and self.entity_distance > distance_threshold then
        if self.parries > 2 then
            self.parries = 1
        end
        print("is_spam: Entity distance too far")
        return false
    end

    if self.ball_distance > self.range and self.entity_distance > distance_threshold then
        if self.parries > 2 then
            self.parries = 2
        end
        print("is_spam: Ball distance too far")
        return false
    end

    if self.last_position_distance > self.spam_accuracy and self.entity_distance > distance_threshold then
        if self.parries > 4 then
            self.parries = 2
        end
        print("is_spam: Last position distance too far")
        return false
    end

    if self.ball_distance > self.spam_accuracy and self.ball_distance > distance_threshold then
        if self.parries > 3 then
            self.parries = 2
        end
        print("is_spam: Ball distance exceeds spam accuracy")
        return false
    end

    if self.entity_distance > self.spam_accuracy and self.entity_distance > (distance_threshold - math.pi) then
        if self.parries > 3 then
            self.parries = 2
        end
        print("is_spam: Entity distance exceeds spam accuracy")
        return false
    end

    print("is_spam: Spam condition met")
    return true
end

function get_closest_entity()
    local closest = nil
    local max_distance = math.huge
    for _, entity in Alive:GetChildren() do
        if entity.Name ~= LocalPlayer.Name and entity:FindFirstChild("HumanoidRootPart") then
            local distance = (LocalPlayer.Character and LocalPlayer.Character.PrimaryPart and (LocalPlayer.Character.PrimaryPart.Position - entity.HumanoidRootPart.Position).Magnitude) or math.huge
            if distance < max_distance then
                closest = entity
                max_distance = distance
                print("get_closest_entity: New closest entity:", entity.Name, "Distance:", distance)
            end
        end
    end
    return closest
end

function Player.get_aim_entity()
    local closest_entity = nil
    local minimal_dot_product = -math.huge
    local camera_direction = Camera and Camera.CFrame.LookVector or Vector3.zero
    for _, player in Alive:GetChildren() do
        if not player or player.Name == LocalPlayer.Name or not player:FindFirstChild("HumanoidRootPart") then
            continue
        end
        local entity_direction = (player.HumanoidRootPart.Position - (Camera and Camera.CFrame.Position or Vector3.zero)).Unit
        local dot_product = camera_direction:Dot(entity_direction)
        if dot_product > minimal_dot_product then
            minimal_dot_product = dot_product
            closest_entity = player
            print("get_aim_entity: Selected entity:", player.Name, "Dot product:", dot_product)
        end
    end
    return closest_entity
end

function Player.get_closest_player_to_cursor()
    local closest_player = nil
    local minimal_dot_product = -math.huge
    local pointer = Camera and Camera.CFrame or CFrame.new()
    for _, player in Alive:GetChildren() do
        if player == LocalPlayer.Character or player.Parent ~= Alive or not player:FindFirstChild("PrimaryPart") then
            continue
        end
        local player_direction = (player.PrimaryPart.Position - (Camera and Camera.CFrame.Position or Vector3.zero)).Unit
        local dot_product = pointer.LookVector:Dot(player_direction)
        if dot_product > minimal_dot_product then
            minimal_dot_product = dot_product
            closest_player = player
            print("get_closest_player_to_cursor: Selected player:", player.Name, "Dot product:", dot_product)
        end
    end
    return closest_player
end

function linear_predict(current, target, speed)
    return current + (target - current) * speed
end

-- Event handlers
ReplicatedStorage.Remotes.PlrHellHooked.OnClientEvent:Connect(function(hooker)
    AutoParry.ball.properties.hell_hook_completed = hooker and hooker.Name == LocalPlayer.Name
    print("PlrHellHooked: Hooker:", hooker and hooker.Name or "nil")
end)

ReplicatedStorage.Remotes.PlrHellHookCompleted.OnClientEvent:Connect(function()
    AutoParry.ball.properties.hell_hook_completed = true
    print("PlrHellHookCompleted: Hell hook completed")
end)

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(_, root)
    print("ParrySuccessAll triggered, Root parent:", root.Parent and root.Parent.Name or "nil")
    task.spawn(function()
        if root.Parent and root.Parent ~= LocalPlayer.Character and root.Parent.Parent == Alive then
            AutoParry.ball.properties.cooldown = false
            AutoParry.ball.properties.last_hit = tick()
            print("ParrySuccessAll: Cooldown reset, Last hit:", tick())
        end
    end)
    if AutoParry.ball.properties.auto_spam then
        if not AutoParry.ball.properties.cooldown then
            AutoParry.Parry()
        end
    end
end)

Workspace.Balls.ChildAdded:Connect(function(child)
    print("Ball added:", child.Name)
    if is_respawned then
        print("Ball addition ignored due to is_respawned")
        return
    end
    is_respawned = true
    local ball_properties = AutoParry.ball.properties
    ball_properties.respawn_time = tick()
    AutoParry.ball.ball_entity = child
    AutoParry.ball.client_ball_entity = child
    print("Ball entity set:", child.Name)
    if AutoParry.ball.ball_entity then
        ConnectionsManager["on_target_change"] = AutoParry.ball.ball_entity:GetAttributeChangedSignal("target"):Connect(function()
            local target = AutoParry.ball.ball_entity:GetAttribute("target")
            print("Target changed to:", target or "nil")
            if target == LocalPlayer.Name and Settings.AutoParryEnabled and not AutoParry.ball.properties.cooldown then
                ball_properties.cooldown = true
                AutoParry.Parry()
                print("Parry triggered due to target change to local player")
                task.delay(0.3, function()
                    if ball_properties.parries > 0 then
                        ball_properties.parries -= 1
                        print("Parries decreased after target change:", ball_properties.parries)
                    end
                end)
                return
            end
            ball_properties.cooldown = false
            ball_properties.old_speed = ball_properties.speed
            ball_properties.last_position = ball_properties.position
            ball_properties.parries += 1
            task.delay(0.3, function()
                if ball_properties.parries > 0 then
                    ball_properties.parries -= 1
                    print("Parries decreased:", ball_properties.parries)
                end
            end)
        end)
    else
        warn("Ball entity not set properly!")
    end
end)

Workspace.Balls.ChildRemoved:Connect(function(child)
    print("Ball removed:", child.Name)
    if child ~= AutoParry.ball.ball_entity then
        print("Removed ball is not current ball entity")
        return
    end
    is_respawned = false
    AutoParry.ball.ball_entity = nil
    AutoParry.ball.client_ball_entity = nil
    if ConnectionsManager["on_target_change"] then
        ConnectionsManager["on_target_change"]:Disconnect()
        ConnectionsManager["on_target_change"] = nil
        print("Disconnected on_target_change")
    end
    AutoParry.reset()
end)

RunService:BindToRenderStep("server_position_simulation", 1, function()
    local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
    if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
        print("server_position_simulation: No character or PrimaryPart")
        return
    end
    local old_position = LocalPlayer.Character.PrimaryPart.Position
    task.delay(ping / 1000, function()
        Player.Entity.properties.server_position = old_position
        print("server_position_simulation: Updated  Updated server position:", old_position)
    end)
end)

RunService.PreSimulation:Connect(function()
    print("PreSimulation step")
    local character = LocalPlayer.Character
    if not character or not character.PrimaryPart then
        print("PreSimulation: No character or PrimaryPart")
        return
    end
    local player_properties = Player.Entity.properties
    player_properties.sword = character:GetAttribute("CurrentlyEquippedSword") or ""
    player_properties.ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
    player_properties.velocity = character.PrimaryPart.AssemblyLinearVelocity
    player_properties.speed = player_properties.velocity.Magnitude
    player_properties.is_moving = player_properties.speed > 30
    print("Player properties updated:", player_properties)

    local ball = AutoParry.ball.ball_entity
    if not ball then
        print("PreSimulation: No ball entity")
        return
    end
    local ball_properties = AutoParry.ball.properties
    local zoomies = ball:FindFirstChild("zoomies")
    ball_properties.position = ball.Position
    ball_properties.velocity = zoomies and zoomies.VectorVelocity or ball.AssemblyLinearVelocity
    ball_properties.distance = (Player.Entity.properties.server_position - ball_properties.position).Magnitude
    ball_properties.speed = ball_properties.velocity.Magnitude
    ball_properties.direction = ball_properties.velocity.Magnitude > 0 and (Player.Entity.properties.server_position - ball_properties.position).Unit or Vector3.zero
    ball_properties.dot = ball_properties.direction:Dot(ball_properties.velocity.Magnitude > 0 and ball_properties.velocity.Unit or Vector3.zero)
    ball_properties.radians = math.rad(math.asin(ball_properties.dot))
    ball_properties.lerp_radians = linear_predict(ball_properties.lerp_radians, ball_properties.radians, 0.8)
    if not (ball_properties.lerp_radians < 0) and not (ball_properties.lerp_radians > 0) then
        ball_properties.lerp_radians = 0.027
    end
    ball_properties.maximum_speed = math.max(ball_properties.speed, ball_properties.maximum_speed)
    print("Ball properties updated:", ball_properties)

    AutoParry.target.current = Alive:FindFirstChild(ball:GetAttribute("target")) or get_closest_entity()
    if ball:GetAttribute("from") then
        AutoParry.target.from = Alive:FindFirstChild(ball:GetAttribute("from"))
    end
    AutoParry.target.aim = (Settings.CursorTargeting and not UserInputService.TouchEnabled and Player.get_closest_player_to_cursor()) or Player.get_aim_entity()
    ball_properties.rotation = ball_properties.position
    if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name and AutoParry.target.aim and AutoParry.target.aim.PrimaryPart then
        ball_properties.rotation = AutoParry.target.aim.PrimaryPart.Position
    end
    print("Targets updated: Current:", AutoParry.target.current and AutoParry.target.current.Name or "nil", "From:", AutoParry.target.from and AutoParry.target.from.Name or "nil", "Aim:", AutoParry.target.aim and AutoParry.target.aim.Name or "nil")

    if AutoParry.target.current and AutoParry.target.current.PrimaryPart then
        local target_server_position = AutoParry.target.current.PrimaryPart.Position
        local target_velocity = AutoParry.target.current.PrimaryPart.AssemblyLinearVelocity
        AutoParry.entity_properties.server_position = target_server_position
        AutoParry.entity_properties.velocity = target_velocity
        AutoParry.entity_properties.distance = LocalPlayer:DistanceFromCharacter(target_server_position)
        AutoParry.entity_properties.direction = (Player.Entity.properties.server_position - target_server_position).Unit
        AutoParry.entity_properties.speed = target_velocity.Magnitude
        AutoParry.entity_properties.is_moving = target_velocity.Magnitude > 0.1
        AutoParry.entity_properties.dot = AutoParry.entity_properties.is_moving and math.max(AutoParry.entity_properties.direction:Dot(target_velocity.Unit), 0) or 0
        print("Entity properties updated:", AutoParry.entity_properties)
    end
    Closest_Entity = get_closest_entity()
end)

ConnectionsManager["Auto Parry"] = RunService.PostSimulation:Connect(function()
    print("PostSimulation step")
    if not Settings.AutoParryEnabled then
        print("AutoParry disabled, resetting...")
        AutoParry.reset()
        return
    end

    local Character = LocalPlayer.Character
    if not Character or Character.Parent == Workspace.Dead or not Character:FindFirstChild("HumanoidRootPart") or not Character:FindFirstChild("Humanoid") or Character.Humanoid.Health <= 0 then
        print("Invalid character state, resetting...")
        AutoParry.reset()
        return
    end

    if not AutoParry.ball.ball_entity then
        AutoParry.ball.ball_entity = AutoParry.Get_Ball()
        if not AutoParry.ball.ball_entity then
            print("No ball entity found!")
            return
        end
    end

    local ball_properties = AutoParry.ball.properties
    if not ball_properties then
        warn("Ball properties not initialized!")
        return
    end
    ball_properties.is_curved = AutoParry.Is_Curved()
    print("Is_Curved result:", ball_properties.is_curved)
    
    local ping_threshold = math.clamp(LocalPlayer:GetNetworkPing() * 1000 / 10, 10, 20)
    local spam_accuracity = ball_properties.maximum_speed / 7 + ping_threshold
    ball_properties.spam_range = ping_threshold + ball_properties.speed / 2.2
    ball_properties.parry_range = ping_threshold + ball_properties.speed / math.pi

    if LocalPlayer.Character and LocalPlayer.Character:GetAttribute("CurrentlyEquippedSword") == 'Titan Blade' then
        ball_properties.parry_range += 11
        ball_properties.spam_range += 2
    end
    print("Ranges updated: Spam:", ball_properties.spam_range, "Parry:", ball_properties.parry_range)

    local distance_to_last_position = LocalPlayer:DistanceFromCharacter(ball_properties.last_curve_position) or 0

    if Settings.AutoSpamEnabled and AutoParry.target.current then
        ball_properties.auto_spam = AutoParry.is_spam({
            speed = ball_properties.speed,
            spam_accuracy = spam_accuracity,
            parries = ball_properties.parries,
            ball_speed = ball_properties.speed,
            range = ball_properties.spam_range / (3.15 - ping_threshold / 10),
            last_hit = ball_properties.last_hit,
            ball_distance = ball_properties.distance,
            maximum_speed = ball_properties.maximum_speed,
            old_speed = ball_properties.old_speed,
            entity_distance = AutoParry.entity_properties.distance,
            last_position_distance = distance_to_last_position
        })
        print("AutoSpam check result:", ball_properties.auto_spam)
    end

    if ball_properties.auto_spam then
        if not ball_properties.cooldown then
            AutoParry.Parry()
            print("Parry triggered due to auto_spam")
        end
        return
    end

    if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name and Settings.AutoSpamEnabled then
        ball_properties.auto_spam = AutoParry.is_spam({
            speed = ball_properties.speed,
            spam_accuracy = spam_accuracity,
            parries = ball_properties.parries,
            ball_speed = ball_properties.speed,
            range = ball_properties.spam_range,
            last_hit = ball_properties.last_hit,
            ball_distance = ball_properties.distance,
            maximum_speed = ball_properties.maximum_speed,
            old_speed = ball_properties.old_speed,
            entity_distance = AutoParry.entity_properties.distance,
            last_position_distance = distance_to_last_position
        })
        print("AutoSpam check for local player result:", ball_properties.auto_spam)
    end

    if ball_properties.auto_spam then
        if not ball_properties.cooldown then
            AutoParry.Parry()
            print("Parry triggered due to auto_spam for local player")
        end
        return
    end
    
    if ball_properties.is_curved then
        print("Parry blocked: Ball is curved")
        return
    end

    if ball_properties.distance > ball_properties.parry_range then
        print("Parry blocked: Distance too far:", ball_properties.distance, ">", ball_properties.parry_range)
        return
    end
    
    if AutoParry.target.current and AutoParry.target.current.Name ~= LocalPlayer.Name then
        print("Parry blocked: Target is not local player:", AutoParry.target.current.Name)
        return
    end

    if not ball_properties.cooldown then
        AutoParry.Parry()
        print("Parry triggered: All conditions met")
    else
        print("Parry blocked: Cooldown active")
    end

    task.spawn(function()
        local cooldown_duration = 0.5 - (ping_threshold / 100)
        task.wait(cooldown_duration)
        ball_properties.cooldown = false
        print("Cooldown reset after", cooldown_duration, "seconds")
    end)
end)

print("VicoX Blade Ball Script Initialized")
